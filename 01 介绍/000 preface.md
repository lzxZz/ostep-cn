# 前言

## 给所有人的一段话
欢迎阅读本书! 我们希望你在阅读的时候尽可能的享受到我们编写本书时候的乐趣.本书叫做**操作系统: 三大简单部分**(在[http://www.ostep.org](http://www.ostep.org)上能够找到本书),该书的标题明显是致敬Richard Feynman关于物理的一系列讲座的笔记. 虽然本书不能达到那位著名物理学家所设定的高标准,但是对你来说,理解什么是操作系统(或者更一般的说"系统")已经足够了.

三个简单部分表示了本书组织上所围绕的三个专题: 虚拟化, 并发性, 持久化.在讨论这些概念的时候,我们会在结尾的地方讨论操作系统所作的最重要的事情,希望你也能有同样的兴趣.学习新知识不是一件有趣的事情吗?至少应该是.

每一个主要的概念都会深入很多章节,这些章节大多数都介绍了当下的特定问题,并展示如何解决这些问题.这些章节都很短,并且尽可能的引用思路真实来源的材料.我们写作的一个目的就是尽可能的让历史清楚一些,我们认为这能够帮助学生理解是什么?并且能够更清楚.例如,看见香肠是如何制作的,对于理解香肠是什么有重大帮助.

本书有一对配套的设施需要介绍.第一个就是问题的**症结**所在.任何时候,我们解决一个问题的时候,第一件事就是陈述最重要的问题是什么? 例如 首先明确**问题的症结**,然后后希望通过文中其他部分介绍的技术,算法,和创意来解决.

在许多地方,我们通过展示OS随着时间推移的行为来解释系统的工作.这些**时间线**是理解的核心,如果你知道发什么了什么,例如,当一个处理器页错误(page fault),你正在使用自己的方式来真正理解虚拟内存的操作.如果你理解了日志文件系统写一个块到磁盘上,你就迈出了征服存储系统的第一步.

文中有很多的旁注和小提示,带有额外的颜色.旁注讨论了相关的(但是可能不太本质),小提示往往可以用于构建你的系统的通用课程.为了方便,本书的末尾给出了这些旁注和小提示的索引(以及问题的症结,)

我们使用最古老的教导方式"对话",贯穿本书,使用了一种不同的方式来呈现材料.来介绍主要的专题概念(正如所见的,以桃子来举例).也使用桃子来作为复习的材料.不论你觉得它们有用还是幽默的,这都是另外一件事了.

每一个主要部分开始的时候,给出操作系统提供的抽象,然后在后续的章节诶中介绍提供该抽象所需要的机制,策略和其他东西.抽象是计算机科学所有角度的基石.所以你应该不会对OS的基石有所意外.

贯穿本书中各个章节,我们尽力使用真实的代码(而不是伪代码),因此对于所有的实际代码,你应该能够输入并且运行.在真实的系统上运行真实的代码是学习OS的最好的方法.所以我们鼓励你做任何能够做的事情.我们也在girhub上提供了代码仓库[https://github.com/remzi-arpacidusseau/ostep-code](https://github.com/remzi-arpacidusseau/ostep-code)

在文中的许多部分,我们布置了一些作业来确保你真的理解了.许多的作业都是简单的模拟OS的一部分.你应该下载作业,并且独立运行测验.模拟作业满足下列要求:对于不同的随机数种子,你应该能产生无限的真实的集合,你也可以告诉模拟器帮你解决问题.因此,你可以不断的测试自己,来确保自己彻底理解.

本书最重要的附录是你学习到的关于OS的如何工作,设计与实现并且自己测试的代码项目.所有的项目(包括示例代码)都是使用C语言编写的.C是简单但强大的最贴近OS的,因此值得将C语言加入你的工具箱.有两类项目是可用的(在线上附录查看)第一个是系统编程项目,该项目适合C语言新手和UNIX新手并且想要学习底层C编程.另一种类型则是基于MIT开发的叫做xv真实OS内核项目,该项目适合有C经验并能想要处理OS中的脏东西(这里指的是那些繁琐复杂的东西,例如许许多多的magic number).在Wisconsin.有三种方式,系统编程或者sv6编程,已经混合项目.

我们对项目的描述,测试框架,可用性有所滞后,查看[https://github.com/remzi-arpacidusseau/ostep-projects](https://github.com/remzi-arpacidusseau/ostep-projects)来查看更多信息.如果你不是班上的成员,你也能够自己做这些项目,来更好的学习这些材料.但是不幸的是,你没有TA(助教)来帮助你,生活中不是所有东西都免费的(但是书籍可以.)

## 给教师
如果你是希望使用本书讲师或者教授,请随意使用.你也许注意到了,在网站上,该书籍是免费的.你也可以在[lulu.com](lulu.com)上购买打印副本.
该书正确的引用如下:
```
Operating Systems: Three Easy Pieces
Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau
Arpaci-Dusseau BooksAugust, 2018 (Version 1.00)
http://www.ostep.org
```
该课程能够相当好的划分为15周一学期的课时,能够覆盖大多数的主题并且有合理的深度.压缩到10周之内讲完则需要删除部分内容.虚拟监视器上有一些章节,我们通常会将其内容压缩到其他地方讲述,要么在虚拟化结束的时候,或者只做为旁注.

本书和其他OS书中略微有些不同的地方是,推迟了一些内容的讲述,直到学生理解了CPU虚拟化和内存虚拟化.在我们的20年教学经验中,学生很难理解并发问题是如何产生的,或者为什么尝试解决它,如果他们没有理解地址空间是什么,什么是进程,或者为什么上下文切换能够在任何时间点触发.一旦他们理解了这些概念,那么介绍线程的概念和这些问题引起的问题变得更容易了.

我们尽可能的使用黑板来讲授致知识.在讲授概念性的知识时,我们会使用黑男来展示主要的观点和例子.讲义用于给学生提供基于材料要解决的具体问题.在实战课上,我们简单的将笔记本连接到投影仪上并进入项目展示真实代码.这种方式特别适合大型讲座和任何的讨论和项目相关的部分.我们一般不会使用PPT,但是我们也提供了一套PPT.

如果你想要这些这些材料的副本,请给我们发送电子邮件.我们已经给世界各地的许多人分享了它们.并且这些人也贡献了一些材料.

最后一个请求,如果你使用了免费的在线章节,请加上超链接,而不是简单的拷贝.这帮助我们追踪使用情况(过去的几年中,已经有了1百万的下载量了),并且能够保证学生能够得到最新的版本.


## 给学生
如果你是正在阅读的学生,感谢!我们对于为你提供了了解OS的材料感到自豪.我们我们都能回想起一些本科教育阶段的一些教科书(例如Hennessy和Pattersion的计算机架构的经典书籍),并且希望本书也能够成为你的正面回忆之一.

你也许注意到了本书是在线免费.主要的原因是:教科书一般比较昂贵.我们希望本书是追求教育的第一波免费材料的第一本.无论他们来自世界的哪里,也不管他们愿意花费多少购买一本书.Failing that, it is one free book, which isbetter than none.(实在是看不懂了)

我们同时希望不论何处,尽可能的为你之处书中引用的原始材料:多年来在OS领域出现的伟大论文的知名学者.想法不会凭空诞生,它们来自于聪明且勤奋的人(包括,,大多数图灵奖得主),因此我们应该尽可能努力尊重他们的想法和人本身.为了做到这一点,我们希望能够更好的理解OS领域发生的革命,而不是简单的书写文字,营造出那些知识都早已存在的幻觉.此外,也许这些引用是鼓励你去深入挖掘,阅读领域内知名的论文是最好的学习方式.

## 致谢
略,请参考原文

## 最后一段话
Yeats有一段话:"教育不是填满一个桶,而是点燃火花".他是正确的,但同时也是错误的.你不得不"填满一个桶",这些笔记能够帮助你学习.毕竟,让你去Google面试的时候,他们问你一个使用信号量(semaphore)的技巧问题,知道什么是信号量也许是一件好事,不是吗?

但是更广泛的说,Yeats的观点是:教育的最重要的一点时让你对一件事感兴趣,自发的了解更多主题相关的知识,而不是不得不消化一些东西,来在课堂上取得一个好成绩.

我们创建本书旨在激发你对OS的兴趣,靠自己的了解更多的知识,和教授讨论这个领域中所有正在进行的激动人心的研究,甚至开展这些研究.这是一个伟大的领域(!),计算机机历史上所有的令人激动和灭秒的想法都是通过这样一种深刻且重要的方式成型的.尽管我们理解这个火种并不能呢个照亮所有人,但是我们希望能够照亮大多数人,或者甚至仅仅是少部分人.因为一旦这个火种被点亮了,那么就是你真正做出一番伟大事业的时候.因此教育的真正要点是:向前走,学习更多的新奇的主题,去学习,去成长,并且最重要的是,找到你自己的火种.


> ## 译者感言
> 最后一段话实在是发人省醒,教育的本质从来都不是传递知识,让学生找到自己真正感兴趣的东西,让学生主动去钻研,这样的学生远优秀于只会遵循老师步骤一步步走的学生.**主动性**这才是做任何事情的核心要素,只有感兴趣的才会有足够的主动性.

> 全书分为三大板块,虚拟化占用了20章,并发占用了10章,持久化占用了17章.其中虚拟化可以说是OS的本质.操作系统本质上就是抽象,一个对底层硬件的抽象,将难以使用的丑陋的硬件接口驯服,转化为统一,优雅的内核接口.之后10章的并发,关注了目前由于摩尔定律失效之后的计算机发展规律变化(从提升单核性能变成提升核数)导致的软件结构变化(从串行到并行,从单机到集群),最后17章的持久化关注了OS对数据的存储问题,从IO设备到文件抽象再到文件系统,最后介绍了分布式文件系统.